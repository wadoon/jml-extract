{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"jml-extract \u00b6 jml-extract provides functionality to extract Java Modelling Language (JML) specification from Java Source Files. The result are a typed AST with JML-annotated nodes. Mission statement: Our goals is to deliver a versatile, simple, lightweight tool that enables the experimenting with the JML or building analysis tools that support Java/JML. This project delivers an API for use inside other verification tools and a simple cli interface which dumps the information into JSON files. By using the Eclipse Java compiler (ECJ), we support Java 13 . We plan to support following levels : Level 0: JML specification are attached as Strings to the corresponding AST nodes. This gives the highest flexibility as JML keeps untouched, but you need to write your own JML parsing. Level 0+: Support for adding annotation processors for translation of annotation to JML specification. You can use IJmlAnnotationProcessor to translate into Level 1: Providing a parse tree of the JML comments. Open question: How should we deal with Java blocks inside JML, e.g. Java in Lambda functions. Level 2: Type-inference of the JML parse trees Usage - Command Line \u00b6 Get a version of the command line via: grade :exe:shadowJar , which generates the executable jar file exe/build/libs/exe-*all.jar . Usage : <main class> [-hv] [--expr] [--in] [--no-bodies] [--show-compiler-options] [--stmt] [--version] [--[no-] vm-classpath] [--encoding=<encoding>] [--java-version=<javaVersion>] [-P=KEY=VALUE]... [-c=PATH...]... [-s=PATH...]... [PATH...] [PATH...] -c, -cp, --classpath=PATH... specify classpath. Entries need to JAR files and folder. You can use ':' for sepearation --encoding=<encoding> set the encoding of the source files --expr treat input as an expression -h, --help show this help message --in read Java source from stdin --java-version=<javaVersion> for future, currently not supported by JmlCore --no-bodies do not parse the bodies of the methods -P=KEY=VALUE set ecj compiler options. `--show-compiler-options` shows all options -s, --source=PATH... Source file to compile against. These files are no taken into account for dumping. --show-compiler-options shows all underlying compiler options --stmt treat input as statements -v, --[no-]verbose --version show program version --[no-]vm-classpath Architecture \u00b6 Simple Layer upon on the Eclipse Java Compiler ( JmlProject.java ) JmlProject uses a lookup register for finding services. Services provides the functionality jml.services . Services are replaceable, e.g. customizing Process Steps \u00b6 Parsing of a Java file including type informations. done by ECJ. Result: CompilationUnit JML Pipeline triggers ( JmlProject::annotateWithJml ): Recognise JML comments: ( IJmlDetection ). Each comment is analyzed if it is a JML comment Information attached to Comment ast node. Wrapper class for access these information JmlComment Assigning JML comments to AST nodes ( IJmlAttacher ) Based upon the type of a JML comment. Information is put into as an additional property in the ASTNode. Access via ASTProperties . Annotation Processing for translating type annotation into JML specifications ( IJmlAnnotationProcessor ). LEVEL 0 ends here. TODO Parse the JML comments into ParserRuleContext (antlr4's parse tree) ( IJmlAstFactory ). See the grammar definitions KeYJmlParser.g4 . Re-annotating the JML comments. JML comments have annotation, a list of identifiers with \"+\" or \"-\" as prefix. The annotations should help tools to filter out comments which are not meant for them. In this step, hooks can update the annotation based upon the ast. LEVEL 1 ends here. TODO We support a type inference for JML expression. The idea is to rewrite JML into Java and using the Java compiler. We need to translate certain aspect also in to this synthetic Java, e.g. Requires rewriting of JML identifiers, and also support for JML constants, sorts, functions, predicates. State of development (TODOs) \u00b6 proper error handling, propagate/accessibility for ECJ errors deliver errors from JML Support of *.jml files Unit and integration tests","title":"jml-extract"},{"location":"#jml-extract","text":"jml-extract provides functionality to extract Java Modelling Language (JML) specification from Java Source Files. The result are a typed AST with JML-annotated nodes. Mission statement: Our goals is to deliver a versatile, simple, lightweight tool that enables the experimenting with the JML or building analysis tools that support Java/JML. This project delivers an API for use inside other verification tools and a simple cli interface which dumps the information into JSON files. By using the Eclipse Java compiler (ECJ), we support Java 13 . We plan to support following levels : Level 0: JML specification are attached as Strings to the corresponding AST nodes. This gives the highest flexibility as JML keeps untouched, but you need to write your own JML parsing. Level 0+: Support for adding annotation processors for translation of annotation to JML specification. You can use IJmlAnnotationProcessor to translate into Level 1: Providing a parse tree of the JML comments. Open question: How should we deal with Java blocks inside JML, e.g. Java in Lambda functions. Level 2: Type-inference of the JML parse trees","title":"jml-extract"},{"location":"#usage-command-line","text":"Get a version of the command line via: grade :exe:shadowJar , which generates the executable jar file exe/build/libs/exe-*all.jar . Usage : <main class> [-hv] [--expr] [--in] [--no-bodies] [--show-compiler-options] [--stmt] [--version] [--[no-] vm-classpath] [--encoding=<encoding>] [--java-version=<javaVersion>] [-P=KEY=VALUE]... [-c=PATH...]... [-s=PATH...]... [PATH...] [PATH...] -c, -cp, --classpath=PATH... specify classpath. Entries need to JAR files and folder. You can use ':' for sepearation --encoding=<encoding> set the encoding of the source files --expr treat input as an expression -h, --help show this help message --in read Java source from stdin --java-version=<javaVersion> for future, currently not supported by JmlCore --no-bodies do not parse the bodies of the methods -P=KEY=VALUE set ecj compiler options. `--show-compiler-options` shows all options -s, --source=PATH... Source file to compile against. These files are no taken into account for dumping. --show-compiler-options shows all underlying compiler options --stmt treat input as statements -v, --[no-]verbose --version show program version --[no-]vm-classpath","title":"Usage - Command Line"},{"location":"#architecture","text":"Simple Layer upon on the Eclipse Java Compiler ( JmlProject.java ) JmlProject uses a lookup register for finding services. Services provides the functionality jml.services . Services are replaceable, e.g. customizing","title":"Architecture"},{"location":"#process-steps","text":"Parsing of a Java file including type informations. done by ECJ. Result: CompilationUnit JML Pipeline triggers ( JmlProject::annotateWithJml ): Recognise JML comments: ( IJmlDetection ). Each comment is analyzed if it is a JML comment Information attached to Comment ast node. Wrapper class for access these information JmlComment Assigning JML comments to AST nodes ( IJmlAttacher ) Based upon the type of a JML comment. Information is put into as an additional property in the ASTNode. Access via ASTProperties . Annotation Processing for translating type annotation into JML specifications ( IJmlAnnotationProcessor ). LEVEL 0 ends here. TODO Parse the JML comments into ParserRuleContext (antlr4's parse tree) ( IJmlAstFactory ). See the grammar definitions KeYJmlParser.g4 . Re-annotating the JML comments. JML comments have annotation, a list of identifiers with \"+\" or \"-\" as prefix. The annotations should help tools to filter out comments which are not meant for them. In this step, hooks can update the annotation based upon the ast. LEVEL 1 ends here. TODO We support a type inference for JML expression. The idea is to rewrite JML into Java and using the Java compiler. We need to translate certain aspect also in to this synthetic Java, e.g. Requires rewriting of JML identifiers, and also support for JML constants, sorts, functions, predicates.","title":"Process Steps"},{"location":"#state-of-development-todos","text":"proper error handling, propagate/accessibility for ECJ errors deliver errors from JML Support of *.jml files Unit and integration tests","title":"State of development (TODOs)"},{"location":"architecture/","text":"Architecture \u00b6 Design descision \u00b6 Simple Layer upon on the Eclipse Java Compiler ( JmlProject.java ) JmlProject uses a lookup register for finding services. Services provides the functionality jml.services . Services are replaceable, e.g. customizing Process Steps \u00b6 Parsing of a Java file including type informations. done by ECJ. Result: CompilationUnit JML Pipeline triggers ( JmlProject::annotateWithJml ): Recognise JML comments: ( IJmlDetection ). Each comment is analyzed if it is a JML comment Information attached to Comment ast node. Wrapper class for access these information JmlComment Assigning JML comments to AST nodes ( IJmlAttacher ) Based upon the type of a JML comment. Information is put into as an additional property in the ASTNode. Access via ASTProperties . Annotation Processing for translating type annotation into JML specifications ( IJmlAnnotationProcessor ). LEVEL 0 ends here. TODO Parse the JML comments into ParserRuleContext (antlr4's parse tree) ( IJmlAstFactory ). See the grammar definitions KeYJmlParser.g4 . Re-annotating the JML comments. JML comments have annotation, a list of identifiers with \"+\" or \"-\" as prefix. The annotations should help tools to filter out comments which are not meant for them. In this step, hooks can update the annotation based upon the ast. LEVEL 1 ends here. TODO We support a type inference for JML expression. The idea is to rewrite JML into Java and using the Java compiler. We need to translate certain aspect also in to this synthetic Java, e.g. Requires rewriting of JML identifiers, and also support for JML constants, sorts, functions, predicates.","title":"Architecture"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#design-descision","text":"Simple Layer upon on the Eclipse Java Compiler ( JmlProject.java ) JmlProject uses a lookup register for finding services. Services provides the functionality jml.services . Services are replaceable, e.g. customizing","title":"Design descision"},{"location":"architecture/#process-steps","text":"Parsing of a Java file including type informations. done by ECJ. Result: CompilationUnit JML Pipeline triggers ( JmlProject::annotateWithJml ): Recognise JML comments: ( IJmlDetection ). Each comment is analyzed if it is a JML comment Information attached to Comment ast node. Wrapper class for access these information JmlComment Assigning JML comments to AST nodes ( IJmlAttacher ) Based upon the type of a JML comment. Information is put into as an additional property in the ASTNode. Access via ASTProperties . Annotation Processing for translating type annotation into JML specifications ( IJmlAnnotationProcessor ). LEVEL 0 ends here. TODO Parse the JML comments into ParserRuleContext (antlr4's parse tree) ( IJmlAstFactory ). See the grammar definitions KeYJmlParser.g4 . Re-annotating the JML comments. JML comments have annotation, a list of identifiers with \"+\" or \"-\" as prefix. The annotations should help tools to filter out comments which are not meant for them. In this step, hooks can update the annotation based upon the ast. LEVEL 1 ends here. TODO We support a type inference for JML expression. The idea is to rewrite JML into Java and using the Java compiler. We need to translate certain aspect also in to this synthetic Java, e.g. Requires rewriting of JML identifiers, and also support for JML constants, sorts, functions, predicates.","title":"Process Steps"},{"location":"howtouse/","text":"How to use \u00b6 Getting Started with the API \u00b6 See Packages for information on the Maven repository and available packages. Note: identifier of groups, artefacts, packages are not fixed yet. JmlProject core = JmlCore . create (); core . setEnvironment ( classpath , sourcefiles ); List < CompilationUnit > units = core . compileAllIn ( \"../examples\" );","title":"How to use"},{"location":"howtouse/#how-to-use","text":"","title":"How to use"},{"location":"howtouse/#getting-started-with-the-api","text":"See Packages for information on the Maven repository and available packages. Note: identifier of groups, artefacts, packages are not fixed yet. JmlProject core = JmlCore . create (); core . setEnvironment ( classpath , sourcefiles ); List < CompilationUnit > units = core . compileAllIn ( \"../examples\" );","title":"Getting Started with the API"}]}